<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Q-ARE-Code breaker? ‚Ä¢ UUID12 QR (Mobile)</title>
  <style>
    :root{ --bg:#e5e7eb; --fg:#0b0f14; --card:#f9fafb; --bd:rgba(0,0,0,.08); --blue:#2563eb; color-scheme: light; }
    html, body{
      height:100%; margin:0; background:var(--bg) !important; color:var(--fg) !important;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    #wrap{
      min-height:100vh; display:flex; flex-direction:column; align-items:center; gap:12px;
      padding:12px 8px calc(90px + env(safe-area-inset-bottom));
    }
    canvas{
      background:var(--card); border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.08), inset 0 0 0 1px rgba(0,0,0,.04);
      touch-action:none;
    }
    #hud{ display:flex; gap:10px; align-items:center; justify-content:center; font-weight:600; flex-wrap:wrap; }
    .pill{ padding:6px 10px; border-radius:999px; background:#f3f4f6; border:1px solid var(--bd); }
    #controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center; }
    .back-fixed{
      position:fixed; left:12px; bottom:calc(16px + env(safe-area-inset-bottom)); z-index:1000;
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px;
      border:1px solid var(--bd); background:rgba(0,0,0,.04); color:var(--fg); font-weight:700; cursor:pointer;
    }
    .back-fixed svg{ opacity:.9 }

    /* ‡πÇ‡∏´‡∏°‡∏î‡∏à‡∏≠‡πÅ‡∏Ñ‡∏ö: overlay ‡∏ã‡πâ‡∏≠‡∏ô‡∏ö‡∏ô‡πÅ‡∏Ñ‡∏ô‡∏ß‡∏≤‡∏™ */
    .stage{ position:relative; display:inline-block; }
    #overlay{ position:absolute; inset:0; display:none; pointer-events:none; }
    #overlay.show{ display:block; }
    #overlay .card{
      position:absolute; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.5); color:#fff; padding:16px 18px; border-radius:14px; text-align:center;
      min-width:260px; pointer-events:auto;
    }
    .btn{ display:inline-block; margin-top:10px; background:var(--blue); color:#fff; border:none; border-radius:10px; font-weight:700; padding:10px 16px; cursor:pointer; }
    .btn-ghost{ display:inline-block; margin-top:10px; background:transparent; color:#fff; border:1px solid rgba(255,255,255,.5); border-radius:10px; font-weight:700; padding:10px 16px; cursor:pointer; }
    #qrPreview{ margin-top:10px; background:#fff; padding:8px; border-radius:10px; display:none; align-items:center; gap:8px; }
    #qrPreview canvas{ width:96px; height:96px; image-rendering: pixelated; border:1px solid rgba(0,0,0,.12); border-radius:6px; }
    #qrResult{ margin-top:10px; font-size:14px; line-height:1.4; text-align:left; }
    #guessBox{ margin-top:6px; display:none; }
    #revealBox{ margin-top:6px; display:none; }

    /* === SIDE-BY-SIDE (>=700px): ‡πÅ‡∏Ñ‡∏ô‡∏ß‡∏≤‡∏™‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á + ‡∏Å‡∏≤‡∏£‡πå‡∏î Game Over ‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏ô‡∏ß‡∏≤‡∏™ === */
    @media (min-width: 700px){
      /* #wrap ‡∏¢‡∏±‡∏á‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏Ç‡∏ß‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‚Üí ‡πÉ‡∏´‡πâ .stage ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ô‡∏ß‡πÅ‡∏ñ‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î [canvas | overlay] */
      .stage{
        display:flex; align-items:flex-start; justify-content:center; gap:12px;
      }
      /* overlay ‡∏ß‡∏≤‡∏á‡∏Ç‡πâ‡∏≤‡∏á‡πÜ (‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏ó‡∏±‡∏ö‡πÅ‡∏Ñ‡∏ô‡∏ß‡∏≤‡∏™) */
      #overlay{
        position:static; display:none; pointer-events:auto;
        width:min(360px, 42vw);
      }
      #overlay.show{ display:block; }
      /* ‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô overlay ‡πÉ‡∏ä‡πâ‡∏™‡∏ß‡πà‡∏≤‡∏á ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á transform */
      #overlay .card{
        position:relative; left:auto; transform:none;
        background:var(--card); color:var(--fg);
        box-shadow:0 10px 30px rgba(0,0,0,.08), inset 0 0 0 1px rgba(0,0,0,.06);
        min-width:auto; text-align:left;
      }
      .btn-ghost{
        color:var(--fg); border:1px solid var(--bd); background:transparent;
      }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
</head>
<body>
  <button id="backBtn" class="back-fixed" type="button" aria-label="‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö
  </button>

  <div id="wrap">
    <div id="hud">
      <div class="pill">High Score: <span id="hiscore">0</span></div>
      <div class="pill">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score">0</span></div>
      <div class="pill">‡πÄ‡∏ß‡∏•‡∏≤: <span id="time">30.0</span>s</div>
      <div class="pill">‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï: <span id="lives">1</span></div>
    </div>

    <div class="stage">
      <canvas id="game" width="360" height="640" aria-label="Q-ARE-Code breaker?"></canvas>

      <div id="overlay">
        <div id="gameOverCard" class="card">
          <div id="gameOverText" style="font-weight:800; font-size:20px; margin-bottom:6px;">Game Over ‚Ä¢ Score: 0</div>

          <!-- ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° -->
          <div id="guessBox">
            <div style="font-weight:700; margin-bottom:6px;">‡πÄ‡∏î‡∏≤‡∏î‡∏π‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏¥!</div>
            <div style="opacity:.95">‡∏à‡∏≤‡∏Å QR ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà ‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏°?</div>
            <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
              <button id="btnGuessYes" class="btn">‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ</button>
              <button id="btnGuessNo" class="btn-ghost">‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</button>
            </div>
          </div>

          <!-- ‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÄ‡∏â‡∏•‡∏¢ -->
          <div id="revealBox">
            <div id="qrPreview">
              <canvas id="qrCanvas" width="140" height="140"></canvas>
              <div id="qrStatusText"></div>
            </div>
            <div id="qrResult"></div>

            <div style="margin-top:10px;">
              <button id="btnRestart" class="btn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="controls">
      <div class="pill"><b>UUID12:</b> <code id="uuidText" style="font-weight:700"></code></div>
      <button id="bleConnectBtn" class="pill" type="button" style="cursor:pointer;">üîó Connect ESP32 (BLE)</button>
      <span id="bleStatus" class="pill">BLE: <b>disconnected</b></span>
    </div>
  </div>

  <script>
  // ===== setup =====
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');

  const scoreEl=document.getElementById('score');
  const timeEl=document.getElementById('time');
  const livesEl=document.getElementById('lives');
  const hiscoreEl=document.getElementById('hiscore');
  const uuidText=document.getElementById('uuidText');

  const overlay=document.getElementById('overlay');
  const gameOverTextEl=document.getElementById('gameOverText');
  const gameOverCard=document.getElementById('gameOverCard');

  const guessBox=document.getElementById('guessBox');
  const btnGuessYes=document.getElementById('btnGuessYes');
  const btnGuessNo=document.getElementById('btnGuessNo');

  const revealBox=document.getElementById('revealBox');
  const btnRestart=document.getElementById('btnRestart');

  const qrPreviewBox=document.getElementById('qrPreview');
  const qrCanvas=document.getElementById('qrCanvas');
  const qrCtx=qrCanvas.getContext('2d');
  const qrResultBox=document.getElementById('qrResult');
  const qrStatusText=document.getElementById('qrStatusText');

  const ROUND_TIME = 30.0;
  const KEY_HISCORE = 'qr_breaker_hiscore_v1';

  window.guessChosen = false;

  const state={
    running:false, level:1, score:0, lives:1,
    paddle:{x:canvas.width/2, y:canvas.height-100, w:70, h:12, speed:9},
    ball:{x:canvas.width/2, y:canvas.height-120, r:6, vx:0, vy:0, speed:5},
    bricks:[], gridMeta:null,
    currentMatrix:null,
    gridScale:0.8,
    effects:[],
    timeLeft: ROUND_TIME,
    lastTS: null,
    showGameOver:false,
    shake:{ time:0, magnitude:0 },
    userGuess:null
  };

  // ---- responsive ----
  function fitCanvas(){
    const baseW=360, baseH=640;
    const maxW=Math.min(window.innerWidth-24, 420);
    const scale=Math.min(maxW/baseW, 1);
    canvas.style.width=Math.round(baseW*scale)+'px';
    canvas.style.height=Math.round(baseH*scale)+'px';
    placeGameOverCard();
  }
  addEventListener('resize',fitCanvas);
  fitCanvas();

  // ---- drawing ----
  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#1f2937'; ctx.fillRect(Math.round(p.x-p.w/2),Math.round(p.y-p.h/2),p.w,p.h); }
  function drawBall(){ const b=state.ball; ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(Math.round(b.x),Math.round(b.y),b.r,0,Math.PI*2); ctx.fill(); }
  function drawBricks(){
    for(const br of state.bricks){
      if(br.cleared || br.hp<=0) continue;
      ctx.fillStyle = (br.hp >= 2) ? '#000000' : '#374151';
      ctx.fillRect(br.x,br.y,br.w,br.h);
    }
  }
  function drawEffects(){
    for(let i=state.effects.length-1; i>=0; i--){
      const e=state.effects[i];
      if(e.kind==='ring'){
        ctx.save(); ctx.globalAlpha = e.alpha; ctx.lineWidth = e.lineWidth; ctx.strokeStyle = e.color;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        ctx.save(); ctx.globalAlpha = e.alpha*0.6; ctx.lineWidth = Math.max(1, e.lineWidth-1); ctx.strokeStyle = '#ffffff';
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r*0.65, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        e.r += e.growth; e.alpha *= e.decay;
        if(e.alpha < 0.04) state.effects.splice(i,1);
      } else if(e.kind==='spark'){
        ctx.save(); ctx.globalAlpha = e.alpha; ctx.lineWidth = 2; ctx.strokeStyle = e.color;
        ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x - Math.cos(e.angle)*e.len, e.y - Math.sin(e.angle)*e.len); ctx.stroke(); ctx.restore();
        e.x += Math.cos(e.angle)*e.speed; e.y += Math.sin(e.angle)*e.speed; e.len *= 0.95; e.alpha *= 0.9;
        if(e.alpha < 0.05 || e.len < 2) state.effects.splice(i,1);
      }
    }
  }
  function drawUI(){}
  function drawFrame(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawBricks(); drawEffects(); drawPaddle(); drawBall(); drawUI(); }

  // ---- gameplay core ----
  function resetBall(onPaddle=true){
    const p=state.paddle, b=state.ball;
    b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; b.vx=0; b.vy=0;
    if(!onPaddle){
      const angle=(-60+Math.random()*120)*Math.PI/180;
      b.vx=Math.cos(angle)*b.speed; b.vy=Math.sin(angle)*b.speed;
    }
  }
  function updateHud(){ scoreEl.textContent=state.score; livesEl.textContent=state.lives; timeEl.textContent=Math.max(0, state.timeLeft).toFixed(1); hiscoreEl.textContent=getHiScore(); }
  function newRound(resetUUID=true){
    state.level=1; state.score=0; state.lives=1; state.timeLeft=ROUND_TIME;
    state.lastTS=null; state.effects.length=0; state.showGameOver=false;
    state.shake.time=0; state.shake.magnitude=0;
    state.userGuess=null;
    window.guessChosen=false;
    overlay.classList.remove('show');
    guessBox.style.display='none'; revealBox.style.display='none'; qrPreviewBox.style.display='none';
    qrResultBox.innerHTML=''; qrStatusText.textContent='';
    updateHud();
    state.paddle.y = canvas.height-80;
    state.ball.y = state.paddle.y - state.paddle.h/2 - state.ball.r - 2;
    resetBall(true); state.running=false;
    if(resetUUID){ makeQRFromUUID(); }
    drawFrame(); placeGameOverCard();
  }
  function gameOver(){
    state.running=false; state.showGameOver=true;
    const hs=getHiScore(); if(state.score>hs) setHiScore(state.score);
    gameOverTextEl.textContent=`Game Over ‚Ä¢ Score: ${state.score}`;
    placeGameOverCard();
    overlay.classList.add('show');
    guessBox.style.display='block';
    revealBox.style.display='none'; qrPreviewBox.style.display='none';
    qrResultBox.innerHTML=''; qrStatusText.textContent='';
    drawFrame();
  }

  function addReflectFlashStrong(cx, cy, baseR){
    const ringColor='#7dd3fc';
    state.effects.push({ kind:'ring', x:cx, y:cy, r:Math.max(3, baseR*0.4), growth:Math.max(2.2, baseR*0.25), alpha:0.9, decay:0.88, lineWidth:3, color:ringColor });
    state.effects.push({ kind:'ring', x:cx, y:cy, r:Math.max(2, baseR*0.22), growth:Math.max(1.7, baseR*0.20), alpha:0.75, decay:0.88, lineWidth:2, color:'#93c5fd' });
    for(let i=0;i<8;i++){
      const angle=Math.random()*Math.PI*2;
      state.effects.push({ kind:'spark', x:cx, y:cy, angle, len:Math.max(8, baseR*0.8)*(0.7+Math.random()*0.6), speed:1.8+Math.random()*1.2, alpha:0.9, color:'#ffffff' });
    }
  }
  function step(ts){
    requestAnimationFrame(step);
    const p=state.paddle, b=state.ball;
    if(state.lastTS==null) state.lastTS=ts;
    const dt=(ts-state.lastTS)/1000; state.lastTS=ts;

    if(state.showGameOver){ drawFrame(); return; }
    if(state.running){
      state.timeLeft-=dt; if(state.timeLeft<=0){ state.timeLeft=0; updateHud(); gameOver(); return; }
    }
    updateHud();

    if (window.bleDir !== 0) movePaddle(window.bleDir);

    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(b.vx===0 && b.vy===0){ b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; }
    b.x+=b.vx; b.y+=b.vy;

    if(b.x-b.r<0){ b.x=b.r; b.vx*=-1; }
    if(b.x+b.r>canvas.width){ b.x=canvas.width-b.r; b.vx*=-1; }
    if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; }
    if(b.y-b.r>canvas.height){ state.lives=0; updateHud(); gameOver(); return; }

    if(b.y+b.r>=p.y-p.h/2 && b.y-b.r<=p.y+p.h/2 && b.x>=p.x-p.w/2 && b.x<=p.x+p.w/2 && b.vy>0){
      const hitPos=(b.x-p.x)/(p.w/2);
      const angle=hitPos*(Math.PI/3);
      const speed=Math.hypot(b.vx,b.vy)*1.015;
      b.vx=Math.sin(angle)*speed; b.vy=-Math.cos(angle)*speed;
      b.y=p.y - p.h/2 - b.r - 1;
      if(b.vy>0) b.vy*=-1;
    }

    for(const br of state.bricks){
      if(br.hp<=0 || br.cleared) continue;
      if(circleRectOverlap(b.x,b.y,b.r,br.x,br.y,br.w,br.h)){
        const dxL=Math.abs((br.x)-(b.x+b.r));
        const dxR=Math.abs((b.x-b.r)-(br.x+br.w));
        const dyT=Math.abs((br.y)-(b.y+b.r));
        const dyB=Math.abs((b.y-b.r)-(br.y+br.h));
        const minPen=Math.min(dxL,dxR,dyT,dyB);
        if(minPen===dxL||minPen===dxR) b.vx*=-1; else b.vy*=-1;

        const hitX=Math.max(br.x, Math.min(b.x, br.x+br.w));
        const hitY=Math.max(br.y, Math.min(b.y, br.y+br.h));
        addReflectFlashStrong(hitX, hitY, Math.min(br.w, br.h));

        br.hp -= 1;
        if (br.hp <= 0){ br.cleared = true; state.score += 10; }
        else { state.score += 3; }
        updateHud();
        break;
      }
    }

    drawBricks(); drawEffects(); drawPaddle(); drawBall(); drawUI();
  }

  function circleRectOverlap(cx,cy,r,rx,ry,rw,rh){
    const nx=Math.max(rx,Math.min(cx,rx+rw)), ny=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy<=r*r;
  }

  // ---- controls ----
  function movePaddle(dirOrX){
    const p=state.paddle;
    if(typeof dirOrX==='number' && Math.abs(dirOrX)<=1){ p.x+=dirOrX*p.speed*2.2; }
    else if(typeof dirOrX==='number'){ p.x=dirOrX; }
    p.x=Math.max(p.w/2, Math.min(canvas.width-p.w/2, p.x));
  }
  function launch(){ if(state.running || state.showGameOver) return; state.running=true; resetBall(false); }

  addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft')  movePaddle(-1);
    if(e.key==='ArrowRight') movePaddle(1);
    if(e.key===' ')          launch();
  });

  let activePointerId=null;
  function pointerToCanvasX(e){
    const rect=canvas.getBoundingClientRect();
    const scaleX=canvas.width/rect.width;
    return (e.clientX - rect.left) * scaleX;
  }
  canvas.addEventListener('pointermove', e=>{
    if (activePointerId===null || activePointerId===e.pointerId || e.pointerType==='mouse'){
      movePaddle(pointerToCanvasX(e));
    }
  }, {passive:true});
  canvas.addEventListener('pointerdown', e=>{
    activePointerId=e.pointerId; canvas.setPointerCapture(activePointerId);
    movePaddle(pointerToCanvasX(e)); launch();
  });
  canvas.addEventListener('pointerup', e=>{
    if (activePointerId===e.pointerId){ canvas.releasePointerCapture(activePointerId); activePointerId=null; }
  });
  canvas.addEventListener('pointercancel', e=>{
    if (activePointerId===e.pointerId){ activePointerId=null; }
  });

  // ---- QR helpers ----
  function uuid12(){
    const bytes=(crypto&&crypto.getRandomValues)?crypto.getRandomValues(new Uint8Array(6)):new Uint8Array(6).map(()=>Math.floor(Math.random()*256));
    return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  function getHiScore(){ const v=parseInt(localStorage.getItem(KEY_HISCORE)||'0',10); return Number.isFinite(v)?v:0; }
  function setHiScore(v){ localStorage.setItem(KEY_HISCORE, String(v)); hiscoreEl.textContent=v; }

  function qrMatrixFromText(text, ecc='M'){
    const qr=qrcode(0, ecc); qr.addData(text); qr.make();
    const n=qr.getModuleCount();
    const mat=[];
    for(let r=0;r<n;r++){ const row=[]; for(let c=0;c<n;c++){ row.push(qr.isDark(r,c)?1:0); } mat.push(row); }
    return mat;
  }

  async function makeQRFromUUID(){
    const id=uuid12();
    uuidText.textContent=id;
    state.currentMatrix=qrMatrixFromText(id, 'M');
    buildBricksFromMatrix(state.currentMatrix);
    resetBall(true); state.running=false; updateHud(); drawFrame();
    placeGameOverCard();
  }

  function buildBricksFromMatrix(mat){
    const rows=mat.length, cols=mat[0].length;
    const maxW=Math.min(canvas.width-16, Math.round(canvas.width*state.gridScale));
    const maxH=Math.floor(Math.min(canvas.height*0.45, canvas.height*state.gridScale));
    let moduleSize=Math.floor(Math.min(maxW/cols, maxH/rows)); moduleSize=Math.max(6, moduleSize);

    const gridW=cols*moduleSize, gridH=rows*moduleSize;
    const startX=Math.floor((canvas.width - gridW)/2);
    const startY=32;

    const bricks=[]; let id=1;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(mat[r][c]!==1) continue;
        const x=startX + c*moduleSize;
        const y=startY + r*moduleSize;
        bricks.push({ id:id++, x,y, w:moduleSize, h:moduleSize, hp:2, type:'black', cleared:false, r, c });
      }
    }
    state.bricks=bricks;
    state.gridMeta={ startX,startY,moduleSize,cols,rows };
  }

  // --- ‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î: ‡∏à‡∏≠‡πÉ‡∏´‡∏ç‡πà‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÉ‡∏´‡πâ CSS ‡∏à‡∏±‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤, ‡∏à‡∏≠‡πÅ‡∏Ñ‡∏ö‡∏ß‡∏≤‡∏á‡πÉ‡∏ï‡πâ‡∏Å‡∏£‡∏¥‡∏î ---
  function placeGameOverCard(){
    const sideMode = window.matchMedia('(min-width: 700px)').matches;

    if (sideMode){
      gameOverCard.style.top = ''; // ‡πÉ‡∏ä‡πâ layout ‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤‡∏ï‡∏≤‡∏° CSS
      return;
    }

    let topY=canvas.height*0.6;
    if(state.gridMeta){
      const gm=state.gridMeta;
      const gridBottom=gm.startY + gm.rows*gm.moduleSize;
      topY=gridBottom + 16;
      const maxTop=canvas.height - 160;
      topY=Math.min(topY, maxTop);
    }
    gameOverCard.style.top = `${Math.round(topY)}px`;
  }

  // ===== ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ & ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ =====
  function matrixFromCurrentGrid(){
    const gm=state.gridMeta; if(!gm) return null;
    const rows=gm.rows, cols=gm.cols;
    const base=state.currentMatrix ? state.currentMatrix.map(row=>row.slice()) : Array.from({length:rows},()=>Array(cols).fill(0));
    const alive=new Set();
    for(const br of state.bricks){ if(br.hp>0 && !br.cleared){ alive.add(br.r+','+br.c); } }
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(base[r][c]===1 && !alive.has(r+','+c)) base[r][c]=0;
      }
    }
    return base;
  }

  function drawMatrixToCanvas(mat, modulePx=6, quiet=4){
    const rows=mat.length, cols=mat[0].length;
    const W=(cols+quiet*2)*modulePx, H=(rows+quiet*2)*modulePx;
    qrCanvas.width=W; qrCanvas.height=H;
    qrCtx.fillStyle='#ffffff'; qrCtx.fillRect(0,0,W,H);
    qrCtx.fillStyle='#000000';
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(mat[r][c]===1){
          const x=(c+quiet)*modulePx, y=(r+quiet)*modulePx;
          qrCtx.fillRect(x,y,modulePx,modulePx);
        }
      }
    }
  }

  function percentBlackLeft(matOriginal, matNow){
    if(!matOriginal || !matNow) return null;
    let want=0, left=0;
    for(let r=0;r<matOriginal.length;r++){
      for(let c=0;c<matOriginal[0].length;c++){
        if(matOriginal[r][c]===1){ want++; if(matNow[r][c]===1) left++; }
      }
    }
    return want? Math.round(left*100/want): 100;
  }

  function checkFinderHealth(mat){
    const sz=7;
    const coords=[
      {r0:0, c0:0, name:'Top-Left'},
      {r0:0, c0:mat[0].length - sz, name:'Top-Right'},
      {r0:mat.length - sz, c0:0, name:'Bottom-Left'},
    ];
    const res=[];
    for(const f of coords){
      let total=0, black=0;
      for(let r=f.r0; r<f.r0+sz; r++){
        for(let c=f.c0; c<f.c0+sz; c++){
          total++; if(mat[r]?.[c]===1) black++;
        }
      }
      res.push({name:f.name, pct: Math.round(black*100/total)});
    }
    return res;
  }

  function checkTimingHealth(matOriginal, matNow){
    const n=matOriginal.length;
    const line=6;
    function pctOnRow(){
      let need=0, left=0;
      for(let c=0;c<n;c++){
        if(matOriginal[line][c]===1){ need++; if(matNow[line][c]===1) left++; }
      }
      return need? Math.round(left*100/need): 100;
    }
    function pctOnCol(){
      let need=0, left=0;
      for(let r=0;r<n;r++){
        if(matOriginal[r][line]===1){ need++; if(matNow[r][line]===1) left++; }
      }
      return need? Math.round(left*100/need): 100;
    }
    return { rowPct:pctOnRow(), colPct:pctOnCol() };
  }

  function revealAnswerAndExplain(){
    const matNow=matrixFromCurrentGrid();
    if(!matNow){ qrResultBox.innerHTML=`<div>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏£‡∏¥‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö QR</div>`; return; }

    drawMatrixToCanvas(matNow, 6, 4);
    qrPreviewBox.style.display='inline-flex';

    const original=(uuidText.textContent||'').trim();
    const pctLeft=percentBlackLeft(state.currentMatrix, matNow);
    const finders=checkFinderHealth(matNow);
    const timing=checkTimingHealth(state.currentMatrix, matNow);

    let readable=false, decoded=null;
    try{
      const imgData=qrCtx.getImageData(0,0,qrCanvas.width,qrCanvas.height);
      const res=jsQR(imgData.data, imgData.width, imgData.height, { inversionAttempts:"attemptBoth" });
      if(res && res.data){ readable=true; decoded=res.data.trim(); }
    }catch(err){}

    qrStatusText.innerHTML = readable
      ? `<b style="color:#0f766e">‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ ‚úÖ</b>`
      : `<b style="color:#b91c1c">‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‚ùå</b>`;

    let html=`<div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢:</b> ${pctLeft==null?'-':(100-pctLeft)}% ‡∏à‡∏≤‡∏Å‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏î‡∏≥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</div>`;
    html+=`<div><b>UUID12 ‡πÄ‡∏î‡∏¥‡∏°:</b> <code>${original||'-'}</code></div>`;

    if(readable){
      html+=`<div><b>‡∏ú‡∏•‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™:</b> <code>${decoded}</code></div>`;
      if(original && decoded!==original){
        html+=`<div style="color:#92400e"><b>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</b> ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏≠‡∏î‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>`;
      }
    } else {
      const issues=[];
      for(const f of finders){ if(f.pct<70) issues.push(`Finder ${f.name} ‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏°‡∏≤‡∏Å (${f.pct}%)`); }
      if(timing.rowPct<60) issues.push(`Timing row (‡πÅ‡∏ñ‡∏ß‡∏Å‡∏•‡∏≤‡∏á) ‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢ (${timing.rowPct}%)`);
      if(timing.colPct<60) issues.push(`Timing column (‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏Å‡∏•‡∏≤‡∏á) ‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢ (${timing.colPct}%)`);
      if(issues.length===0){ issues.push('‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡πÇ‡∏°‡∏î‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà ECC ‡∏£‡∏∞‡∏î‡∏±‡∏ö M ‡∏à‡∏∞‡∏ä‡∏î‡πÄ‡∏ä‡∏¢‡πÑ‡∏î‡πâ'); }
      html+=`<div style="margin-top:6px;"><b>‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏´‡∏•‡∏±‡∏Å:</b><ul style="margin:6px 0 0 18px;">${issues.map(s=>`<li>${s}</li>`).join('')}</ul></div>`;
    }

    html+=`<div style="margin-top:6px;">Finder ‚Ä¢ ${finders.map(f=>`${f.name}: ${f.pct}%`).join(' ‚Ä¢ ')}<br/>Timing ‚Ä¢ Row: ${timing.rowPct}% ‚Ä¢ Col: ${timing.colPct}%</div>`;

    if(state.userGuess!==null){
      const correct=(state.userGuess===readable);
      html+=`<div style="margin-top:8px; font-weight:700; ${correct?'color:#065f46':'color:#7f1d1d'}">
        ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì: ${state.userGuess ? '‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ' : '‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ'} ‚Üí ${correct ? '‡∏ï‡∏£‡∏á ‚úÖ' : '‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á ‚ùå'}
      </div>`;
    }

    html+=`<div style="opacity:.85; margin-top:6px; font-size:12px">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô Finder/Timing + ‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ñ‡∏≠‡∏î‡∏à‡∏£‡∏¥‡∏á‡∏î‡πâ‡∏ß‡∏¢ jsQR</div>`;
    qrResultBox.innerHTML=html;
  }

  // ---- Interaction: ‡πÄ‡∏î‡∏≤ ‚Üí ‡πÄ‡∏â‡∏•‡∏¢ ----
  btnGuessYes.addEventListener('click', ()=>{
    state.userGuess=true; window.guessChosen=true;
    guessBox.style.display='none'; revealBox.style.display='block'; revealAnswerAndExplain();
  });
  btnGuessNo.addEventListener('click', ()=>{
    state.userGuess=false; window.guessChosen=true;
    guessBox.style.display='none'; revealBox.style.display='block'; revealAnswerAndExplain();
  });
  btnRestart.addEventListener('click', ()=>{ newRound(true); });

  // ---- init ----
  hiscoreEl.textContent=getHiScore();
  newRound(true);
  requestAnimationFrame(step);

  // back button
  document.getElementById('backBtn').addEventListener('click', function(e){
    e.preventDefault();
    try{
      if(document.referrer && new URL(document.referrer).origin===location.origin){ history.back(); }
      else { location.href='index.html'; }
    }catch(err){ history.back(); }
  });
  </script>

  <!-- ===== Web Bluetooth glue (‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö main.py) ===== -->
  <script>
    const SERVICE_UUID = '12345678-1234-1234-1234-1234567890ab';
    const CHAR_UUID    = 'abcd1234-1234-1234-1234-abcdef012345';

    window.bleDir = 0;
    let bleDevice=null, bleCharacteristic=null;
    let lastMaskFromBle=0, lastGuessMs=0;

    function setBleStatus(text){
      const el=document.getElementById('bleStatus');
      if(el) el.innerHTML='BLE: <b>'+text+'</b>';
      console.log('[BLE]', text);
    }
    function parseButtons(v){
      const leftPressed  = (v & 0x01) !== 0;
      const rightPressed = (v & 0x02) !== 0;
      const bothPressed  = (v & 0x03) === 0x03;
      return { leftPressed, rightPressed, bothPressed };
    }
    function onBleButtonsChanged(ev){
      const v = ev.target.value.getUint8(0);
      const {leftPressed, rightPressed, bothPressed} = parseButtons(v);

      const inGameOver = state.showGameOver && (
        document.getElementById('guessBox').style.display !== 'none' ||
        document.getElementById('revealBox').style.display !== 'none'
      );

      if(inGameOver){
        if(!window.guessChosen){
          const now=Date.now();
          if(leftPressed && !(lastMaskFromBle & 0x01) && guessBox.style.display!=='none' && (now-lastGuessMs>150)){
            btnGuessYes.click(); lastGuessMs=now;
          }
          if(rightPressed && !(lastMaskFromBle & 0x02) && guessBox.style.display!=='none' && (now-lastGuessMs>150)){
            btnGuessNo.click(); lastGuessMs=now;
          }
        }else{
          const wasBoth = (lastMaskFromBle & 0x03) === 0x03;
          if(bothPressed && !wasBoth) btnRestart.click();
        }
        lastMaskFromBle=v; window.bleDir=0; return;
      }

      window.bleDir = (leftPressed && !rightPressed) ? -1 :
                      (rightPressed && !leftPressed) ?  1 : 0;

      const wasBoth=(lastMaskFromBle & 0x03) === 0x03;
      if(bothPressed && !wasBoth && !state.running && !state.showGameOver){ launch(); }

      lastMaskFromBle=v;
    }

    async function connectBle(){
      try{
        if(!('bluetooth' in navigator)){ alert('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Web Bluetooth'); return; }
        if(!window.isSecureContext && !['localhost','127.0.0.1'].includes(location.hostname)){
          alert('‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô HTTPS ‡∏´‡∏£‡∏∑‡∏≠ http://localhost/127.0.0.1 ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô'); return;
        }

        setBleStatus('pairing‚Ä¶');

        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [
            { services: [SERVICE_UUID] },
            { namePrefix: 'QR-Paddle' }
          ],
          optionalServices: [SERVICE_UUID]
        });

        bleDevice.addEventListener('gattserverdisconnected', ()=>{
          setBleStatus('disconnected');
        });

        const server  = await bleDevice.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        bleCharacteristic = await service.getCharacteristic(CHAR_UUID);

        await bleCharacteristic.startNotifications();
        bleCharacteristic.addEventListener('characteristicvaluechanged', onBleButtonsChanged);

        setBleStatus('connected');
      }catch(err){
        console.error('[BLE] connect error:', err);
        setBleStatus('error'); setTimeout(()=>setBleStatus('disconnected'), 1200);
      }
    }

    document.getElementById('bleConnectBtn')?.addEventListener('click', connectBle);
  </script>
</body>
</html>