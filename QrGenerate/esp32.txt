/*
 * ESP32 MQTT Distance Sensor - สำหรับเชื่อมต่อ RPi เท่านั้น
 * - เชื่อมต่อ WiFi กับ RPi Hotspot (rpi-local1) เท่านั้น
 * - MQTT ไปที่ RPi (10.42.0.1)
 * - ไม่มีการเชื่อมต่ออินเทอร์เน็ตอื่นใด
 */

#include <WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <Adafruit_VL53L1X.h>
#include "esp_wifi.h"

/* ===================== ตั้งค่าพื้นฐาน ===================== */
#define SITE_NAME   "gateA"
#define DEVICE_ID   "esp32-01"

// ตั้งค่าระยะ
const uint16_t NEAR_MM     = 150;
const uint16_t FAR_MM      = 160;
const uint32_t COOLDOWN_MS = 2500;

// ตั้งค่า I2C
#define SDA 21
#define SCL 22
const uint32_t I2C_HZ = 400000;

/* ===================== ตั้งค่า WiFi และ MQTT ===================== */
// ตั้งค่า WiFi สำหรับ RPi Hotspot
#define WIFI_SSID      "rpi-local1"
#define WIFI_PASS      "12345678"

// ตั้งค่า MQTT Broker (RPi)
#define MQTT_HOST_IP   IPAddress(10,42,0,1)
#define MQTT_PORT      1883
#define MQTT_USER      "sensor1"
#define MQTT_PASS      "12345678"

// ใช้ Static IP สำหรับความเสถียร
#define USE_STATIC_IP  1
IPAddress IP(10,42,0,56);
IPAddress GW(10,42,0,1);
IPAddress MASK(255,255,255,0);
IPAddress DNS(10,42,0,1);

/* ===================== ตัวแปร全局 ===================== */
WiFiClient       wifiClient;
PubSubClient     client(wifiClient);
Adafruit_VL53L1X vl = Adafruit_VL53L1X();

// ตัวแปรสถานะ
enum FsmState { FAR_STATE, NEAR_STATE };
FsmState state = FAR_STATE;
unsigned long lastTrigMs = 0;

// ตัวแปรจัดการการเชื่อมต่อ
uint32_t wifiBackoff = 1000;
uint32_t mqttBackoff = 1200;
int wifiReconnectCount = 0;
unsigned long lastWifiReconnectAttempt = 0;
unsigned long lastHealthCheck = 0;
unsigned long lastRestartCheck = 0;
int consecutiveWiFiFails = 0;

// ===================== ฟังก์ชันใช้งานทั่วไป =====================
uint16_t median5(uint16_t a, uint16_t b, uint16_t c, uint16_t d, uint16_t e) {
  uint16_t arr[5] = {a, b, c, d, e};
  for (int i = 0; i < 4; i++) {
    for (int j = i + 1; j < 5; j++) {
      if (arr[i] > arr[j]) {
        uint16_t temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr[2];
}

String topic(const char* t) {
  return String(SITE_NAME) + "/" + DEVICE_ID + "/" + t;
}

// ===================== ฟังก์ชันจัดการ WiFi =====================
void setupWiFi() {
  Serial.println("[WiFi] กำลังตั้งค่า WiFi สำหรับ RPi...");
  
  // ตั้งค่า WiFi ให้เหมาะสม
  WiFi.persistent(false);
  WiFi.mode(WIFI_STA);  // โหมด Station เท่านั้น
  WiFi.setSleep(false);
  WiFi.setAutoReconnect(true);
  
  // ตั้งค่าให้เหมาะสมกับ RPi Hotspot
  WiFi.setTxPower(WIFI_POWER_19_5dBm);
  esp_wifi_set_ps(WIFI_PS_NONE);
  
  // ตั้งค่า Static IP
#if USE_STATIC_IP
  WiFi.config(IP, GW, MASK, DNS);
  Serial.printf("[WiFi] ตั้งค่า Static IP: %s\n", IP.toString().c_str());
#endif

  // ตั้งชื่อ host
  char hostname[32];
  snprintf(hostname, sizeof(hostname), "%s-%s", SITE_NAME, DEVICE_ID);
  WiFi.setHostname(hostname);
  
  // ล้างการเชื่อมต่อเก่า
  WiFi.disconnect(true, true);
  delay(1000);
  
  Serial.printf("[WiFi] พร้อมเชื่อมต่อกับ RPi: %s\n", WIFI_SSID);
  Serial.printf("[WiFi] Hostname: %s\n", hostname);
}

void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  
  unsigned long currentTime = millis();
  
  // รอให้ครบเวลาก่อน reconnect ครั้งใหม่
  if (currentTime - lastWifiReconnectAttempt < wifiBackoff) {
    return;
  }
  
  lastWifiReconnectAttempt = currentTime;
  wifiReconnectCount++;
  
  Serial.printf("[WiFi] พยายามเชื่อมต่อ RPi ครั้งที่ %d...\n", wifiReconnectCount);
  
  // ล้างการเชื่อมต่อเก่า
  WiFi.disconnect(true, true);
  delay(500);
  
  // เริ่มการเชื่อมต่อกับ RPi เท่านั้น
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  // รอการเชื่อมต่อ
  int waitCount = 0;
  while (WiFi.status() != WL_CONNECTED && waitCount < 30) { // เพิ่มเวลาเป็น 15 วินาที
    delay(500);
    Serial.print(".");
    waitCount++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n[WiFi] เชื่อมต่อ RPi สำเร็จ!");
    Serial.printf("[WiFi] IP: %s, RSSI: %d dBm\n", 
                  WiFi.localIP().toString().c_str(), WiFi.RSSI());
    
    // รีเซ็ตตัวนับเมื่อเชื่อมต่อสำเร็จ
    wifiReconnectCount = 0;
    consecutiveWiFiFails = 0;
    wifiBackoff = 1000;
  } else {
    Serial.printf("\n[WiFi] เชื่อมต่อ RPi ล้มเหลว (สถานะ: %d)\n", WiFi.status());
    consecutiveWiFiFails++;
    
    // เพิ่ม backoff time
    wifiBackoff = min(wifiBackoff * 2, 30000UL);
    
    // ถ้าล้มเหลวหลายครั้งเกินไป
    if (consecutiveWiFiFails > 8) {
      Serial.println("[WiFi] รีสตาร์ทระบบเครือข่าย...");
      aggressiveWiFiRecovery();
    }
  }
}

void aggressiveWiFiRecovery() {
  Serial.println("[WiFi] เริ่มกู้คืนการเชื่อมต่อ...");
  
  // รีเซ็ต WiFi stack
  WiFi.disconnect(true, true);
  delay(1000);
  WiFi.mode(WIFI_OFF);
  delay(1000);
  WiFi.mode(WIFI_STA);
  
  // ตั้งค่าใหม่
  setupWiFi();
  
  // ลองเชื่อมต่ออีกครั้ง
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  Serial.println("[WiFi] กู้คืนการเชื่อมต่อเสร็จสิ้น");
}

void checkWiFiHealth() {
  unsigned long currentTime = millis();
  
  // ตรวจสอบทุก 10 วินาที
  if (currentTime - lastHealthCheck < 10000) return;
  
  lastHealthCheck = currentTime;
  
  if (WiFi.status() == WL_CONNECTED) {
    int rssi = WiFi.RSSI();
    Serial.printf("[WiFi-Health] RSSI: %d dBm\n", rssi);
    
    if (rssi < -80) {
      Serial.println("[WiFi-Health] ⚠️  สัญญาณอ่อน! พิจารณาย้าย ESP32 ให้ใกล้ RPi");
    }
  }
}

void checkForRestart() {
  unsigned long currentTime = millis();
  
  // ตรวจสอบทุก 2 นาที
  if (currentTime - lastRestartCheck < 120000) return;
  
  lastRestartCheck = currentTime;
  
  // ถ้า WiFi หลุดต่อเนื่องเกิน 10 นาที，รีสตาร์ท
  if (consecutiveWiFiFails > 30) {
    Serial.println("[WiFi] ⚠️  ไม่สามารถเชื่อมต่อ RPi ได้นานเกินไป，กำลังรีสตาร์ท...");
    delay(1000);
    ESP.restart();
  }
}

// ฟังก์ชันรับ event จาก WiFi
void onWiFiEvent(WiFiEvent_t event, arduino_event_info_t info) {
  switch (event) {
    case ARDUINO_EVENT_WIFI_STA_CONNECTED:
      Serial.println("[WiFi] เชื่อมต่อกับ RPi สำเร็จ");
      break;
      
    case ARDUINO_EVENT_WIFI_STA_GOT_IP:
      Serial.printf("[WiFi] ได้รับ IP จาก RPi: %s\n", WiFi.localIP().toString().c_str());
      wifiReconnectCount = 0;
      consecutiveWiFiFails = 0;
      wifiBackoff = 1000;
      break;
      
    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
      {
        uint8_t reason = info.wifi_sta_disconnected.reason;
        Serial.printf("[WiFi] ถูกตัดการเชื่อมต่อจาก RPi (เหตุผล: %d)\n", reason);
      }
      break;
      
    default:
      break;
  }
}

// ===================== ฟังก์ชันจัดการ MQTT =====================
void onMqttMessage(char* topic, byte* payload, unsigned int length) {
  String message;
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.printf("[MQTT] รับข้อความ: %s -> %s\n", topic, message.c_str());
}

bool connectMQTT() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[MQTT] ขาดการเชื่อมต่อ WiFi，ไม่สามารถเชื่อมต่อ MQTT ได้");
    return false;
  }
  
  // สร้าง client ID จาก MAC address
  uint8_t mac[6];
  WiFi.macAddress(mac);
  char clientId[32];
  snprintf(clientId, sizeof(clientId), "%s-%02X%02X%02X", DEVICE_ID, mac[3], mac[4], mac[5]);
  
  String willTopic = topic("status/online");
  
  Serial.print("[MQTT] กำลังเชื่อมต่อกับ RPi MQTT... ");
  
  bool connected = client.connect(
    clientId,
    MQTT_USER,
    MQTT_PASS,
    willTopic.c_str(),
    1,
    true,
    "offline",
    true
  );
  
  if (connected) {
    Serial.println("สำเร็จ!");
    
    // ส่งข้อความบอกว่า online
    client.publish(willTopic.c_str(), "online", true);
    
    // ติดตาม topic ที่ต้องการ
    client.subscribe(topic("ui/#").c_str(), 1);
    
    mqttBackoff = 1200;
    Serial.println("[MQTT] ติดตาม topic ui/# แล้ว");
  } else {
    Serial.printf("ล้มเหลว! (รหัสผิดพลาด: %d)\n", client.state());
    mqttBackoff = min(mqttBackoff * 2, 60000UL);
  }
  
  return connected;
}

void handleMQTT() {
  static unsigned long lastMQTTAattempt = 0;
  
  if (!client.connected()) {
    unsigned long currentTime = millis();
    
    if (currentTime - lastMQTTAattempt >= mqttBackoff) {
      lastMQTTAattempt = currentTime;
      
      if (WiFi.status() == WL_CONNECTED) {
        connectMQTT();
      }
    }
  } else {
    client.loop();
  }
}

// ===================== ฟังก์ชันจัดการเซ็นเซอร์ =====================
void resetI2C() {
  Wire.end();
  delay(10);
  Wire.begin(SDA, SCL);
  Wire.setClock(I2C_HZ);
  delay(10);
}

bool setupVL53L1X() {
  Serial.println("[VL53L1X] กำลังตั้งค่าเซ็นเซอร์...");
  
  bool initialized = vl.begin(0x29, &Wire);
  
  if (initialized) {
    vl.startRanging();
    Serial.println("[VL53L1X] พร้อมใช้งาน!");
  } else {
    Serial.println("[VL53L1X] ตั้งค่าไม่สำเร็จ!");
  }
  
  return initialized;
}

bool readFilteredDistance(uint16_t &distanceMM) {
  // รอให้เซ็นเซอร์พร้อม
  for (int i = 0; i < 10; i++) {
    if (vl.dataReady()) break;
    delay(5);
  }
  
  // อ่าน 5 ค่า
  uint16_t readings[5];
  for (int i = 0; i < 5; i++) {
    if (!vl.dataReady()) delay(10);
    readings[i] = vl.distance();
    vl.clearInterrupt();
    delay(5);
  }
  
  // ตรวจสอบค่าผิดปกติ
  int badReadings = 0;
  for (int i = 0; i < 5; i++) {
    if (readings[i] == 0 || readings[i] == 65535) {
      badReadings++;
    }
  }
  
  if (badReadings >= 3) {
    Serial.println("[VL53L1X] ค่าผิดปกติมากเกินไป, รีเซ็ตเซ็นเซอร์...");
    resetI2C();
    setupVL53L1X();
    delay(50);
    return false;
  }
  
  // หาค่ากลาง
  distanceMM = median5(readings[0], readings[1], readings[2], readings[3], readings[4]);
  return true;
}

// ===================== ฟังก์ชันหลัก =====================
bool lastPresenceState = false;

void publishPresence(bool present, uint16_t distanceMM) {
  if (!client.connected()) {
    Serial.println("[PRESENCE] MQTT ไม่พร้อม – ข้ามการส่งสถานะ");
    return;
  }

  if (present == lastPresenceState && present) {
    // already reported near, avoid spamming same value
    return;
  }

  lastPresenceState = present;

  char payload[96];
  snprintf(
    payload,
    sizeof(payload),
    "{\"present\":%s,\"distance\":%u,\"ts\":%lu}",
    present ? "true" : "false",
    static_cast<unsigned int>(distanceMM),
    millis()
  );

  client.publish(topic("event/presence").c_str(), payload, false);
  Serial.printf("[PRESENCE] ส่งสถานะ: %s (distance=%u)\n", present ? "present" : "absent", distanceMM);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println();
  Serial.println("==================================");
  Serial.println("   ESP32 MQTT Distance Sensor");
  Serial.println("    สำหรับเชื่อมต่อ RPi เท่านั้น");
  Serial.println("==================================");
  
  // ตั้งค่า WiFi
  WiFi.onEvent(onWiFiEvent);
  setupWiFi();
  
  // เชื่อมต่อ WiFi เริ่มต้น
  Serial.printf("[WiFi] กำลังเชื่อมต่อกับ RPi: %s", WIFI_SSID);
  unsigned long startTime = millis();
  
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  // รอการเชื่อมต่อ (ไม่เกิน 20 วินาที)
  while (WiFi.status() != WL_CONNECTED && millis() - startTime < 20000) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[WiFi] เชื่อมต่อ RPi สำเร็จ! IP: %s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("[WiFi] เชื่อมต่อ RPi ไม่สำเร็จในครั้งแรก，จะลองใหม่ใน loop");
  }
  
  // ตั้งค่า MQTT
  client.setServer(MQTT_HOST_IP, MQTT_PORT);
  client.setCallback(onMqttMessage);
  client.setKeepAlive(60);
  client.setSocketTimeout(15);
  
  // ตั้งค่าเซ็นเซอร์
  Wire.begin(SDA, SCL);
  Wire.setClock(I2C_HZ);
  setupVL53L1X();
  
  Serial.println("✅ ตั้งค่าเสร็จสิ้น，เริ่มทำงาน...");
}

void loop() {
  // Heartbeat ทุก 5 วินาที
  static unsigned long lastHeartbeat = 0;
  if (millis() - lastHeartbeat > 5000) {
    lastHeartbeat = millis();
    
    if (client.connected()) {
      client.publish(topic("status/ping").c_str(), "ok", true);
    }
    
    int wifiStatus = WiFi.status();
    int rssi = (wifiStatus == WL_CONNECTED) ? WiFi.RSSI() : -999;
    
    Serial.printf("[HEARTBEAT] WiFi: %d, สัญญาณ: %d dBm, MQTT: %d\n", 
                 wifiStatus, rssi, client.connected());
  }
  
  // ตรวจสอบสุขภาพระบบ
  checkWiFiHealth();
  checkForRestart();
  
  // จัดการการเชื่อมต่อ WiFi
  if (WiFi.status() != WL_CONNECTED) {
    connectWiFi();
    delay(100);
    return;
  }
  
  // จัดการ MQTT
  handleMQTT();
  
  // อ่านค่าจากเซ็นเซอร์
  uint16_t distanceMM;
  if (!readFilteredDistance(distanceMM)) {
    delay(50);
    return;
  }
  
  // ตรวจสอบสถานะ (ใกล้/ไกล)
  bool isNear = (distanceMM > 0 && distanceMM < NEAR_MM);
  bool isFar = (distanceMM == 0 || distanceMM > FAR_MM);
  
  // เปลี่ยนสถานะและส่งการตรวจจับ
  if (state == FAR_STATE && isNear && (millis() - lastTrigMs > COOLDOWN_MS)) {
    lastTrigMs = millis();
    state = NEAR_STATE;
    publishPresence(true, distanceMM);
  } else if (state == NEAR_STATE && isFar) {
    state = FAR_STATE;
    publishPresence(false, distanceMM);
  }
  
  delay(10);
}
